Ale is a thin layer above Yaws to make web development with Yaws easier. It
provides:
* Sinatra-like routes (http://github.com/sinatra/sinatra)
* Gettext
* Some other utilities and conventions

== Create new project

Yaws 1.83

== Routes

A route maps method and URI to controller and action. Routes are defined in
controllers.

routes() -> [
	get,    "articles",         index,
	get,    "articles/Id",      show,
	get,    "articles/new",     new,
	post,   "articles",         create,
	get,    "articles/Id/edit", edit,
	put,    "articles/Id",      update,
	delete, "articles/Id",      delete
].

Fixed parts are in lower case, variable parts are captitalized.

Function names are used so that filters can used their names.

== controller_application

This controller defines common functionalities for all other controllers:
* error_404 and error_500, these functions do not use layout to avoid the case
  there is error in the layout
* Layout
* Filters

== Order of Function Calling

Before filters -> Action -> View -> Layout.

== Action

Each request is processed by a separate process. For convinience, output to Yaws
is not forced to be the last line of your action. Use ale:put/3-5 to put things
to namespaces in the process dictionary. Things in the "yaws" namespace will be
collected into a list and sent to Yaws.

== Views

If your controller is c_x and action is y, v_x_y:render/0 will be called. Your
actions should call ale:app(Key, Thing) to put things to the "app"
namespace, ale:app(Key) in your views to get them.

If you want to use a view other than the default view, in your action call
ale:view(ViewModule).

If there is no default view or the specified view does not exist, no view will
be called. If you do not want to use a view, just don't create the default view,
or call ale:erase(ale, view). In this case layout will also not be called.

== Layout

To output your view with a layout, call ale:layout(LayoutModule).
LayoutModule:render/0 will be called. To get the rendered view, in your layout
call ale:content_for_layout().

== JavaScript

Call ale:script(Script) to add Script to the process dictionary. Near the end of
your layout, call ale:script(). ale:script(Script) can be called many times to
add many script fragments.

== Before Filter

c_application or any controller can define
before_filter(Controller, Action, Args). To halt the processing chain, this
function should return true.

== Session

For simplicity, only in-coookie session is supported.

== Cache

Page, action, and fragment are all cached in memcached. The advantage of caching
pages in memcached instead of on disk is that expiration time can be specified
for pages.

== Tips

When developing, to compile and reload code after a change, from EShell run
ale:sync()., it will call make:all([load]), which runs Emakefile to compile then
reload. make is a standard module of Erlang.

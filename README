Ale is a thin layer above Yaws to make web development with Yaws easier. It
provides:
* Sinatra-like routes (http://github.com/sinatra/sinatra)
* i18n with Gettext
* Distributed memory caching for pages, actions, fragments, and objects
* Some conventions

== Install and Create New Project

Dependent libraries:
* Yaws 1.84

TODO

== Routes

A route maps method and URI to controller and action. Routes are defined in
controllers.

routes() -> [
	get,    "/articles",         index,
	get,    "/articles/Id",      show,
	get,    "/articles/new",     new,
	post,   "/articles",         create,
	get,    "/articles/Id/edit", edit,
	put,    "/articles/Id",      update,
	delete, "/articles/Id",      delete
].

Fixed parts are in lower case, variable parts are captitalized.

Function names are used so that filters can used their names.

== c_application

This controller defines common functionalities for all other controllers:
* error_404 and error_500, these functions do not use layout to avoid the case
  there is error in the layout
* Layout
* Filters

== Order of Function Calling

Before filters -> Action -> View -> Layout.

== Action

Each request is processed by a separate process. For convinience, output to Yaws
is not forced to be the last line of your action. Use ale:put/3-5 to put things
to namespaces in the process dictionary. Things in the "yaws" namespace will be
collected into a list and sent to Yaws.

== View

If your controller is c_hello and action is world, v_hello_world:render/0 will
be called. Your action should call ale:app(Key, Thing) to put things to the
"app" namespace, your view should call ale:app(Key) to get things back.

If you want to use a view other than the default view, in your action call
ale:view(ViewModule).

If there is no default view or the specified view does not exist, no view will
be called. If you do not want to use a view, just don't create the default view,
or call ale:erase(ale, view). In this case layout will also not be called.

== Layout

To output your view with a layout, call ale:layout(LayoutModule).
LayoutModule:render/0 will be called. To get the rendered view, in your layout
call ale:content_for_layout().

== JavaScript

Call ale:script(Script) to add Script to the process dictionary. Near the end of
your layout, call ale:script(). ale:script(Script) can be called many times to
add many script fragments.

== Before Filter

c_application or any controller can define
before_filter(Controller, Action, Args). To halt the processing chain, this
function should return true.

== Session

TODO

== Cache

Page, action, fragment, and object are all cached in memory. The advantage of
caching pages in memory instead of on disk is that expiration time can be specified
for pages. For a certain action, types of caching should be mutual exclusive,
e.g. if the action is already set to be page cached then it should not also set
as action cached.

== Tips

When developing, to compile and reload code after a change, from EShell run
ale:sync()., it will call make:all([load]), which runs Emakefile to compile then
reload. make is a standard module of Erlang.

%%% This module creates the routing function used in ale_yaws_mod:
%%% route_path(Method, Path) -> {Controller, Action, Args} | no_route

-module(ale_routes_gen).

-compile(export_all).

gen() ->
    io:format("Collect routes...~n"),
    Forms = filelib:fold_files(".", "^c_.*\.beam$", true,
        fun(FileName, Acc) ->
            BaseName = filename:basename(FileName, ".beam"),
            io:format("  ~s...\n", [BaseName]),
            ControllerModule = list_to_atom(BaseName),
            case parse(ControllerModule) of
                undefined -> Acc;
                Form      -> [Form | Acc]
            end
        end,
        []
    ),

    Source = [
        "% This file is autogenerated by ale_routes_gen. Do not edit because your edit\n% will be lost when this file is regenerated.\n"
        "-module(ale_routes).\n\n"

        "-export([route_path/2, path/3]).\n\n"

        "route_path(Method, Path) -> Tokens = string:tokens(Path, \"/\"), route_tokens(Method, Tokens).\n",
        route_tokens_gen(Forms),
        "\nroute_tokens(_, _) -> no_route.\n",

        path_gen(Forms),
        "\npath(Controller, Action, Params) -> erlang:error({no_path, [Controller, Action, Params]}).\n"
    ],
    file:write_file("ale_routes.erl", Source).

%-------------------------------------------------------------------------------

%% Returns {ControllerModule, [{Method, [{fixed, Fixed} | {param, Param}], Action}]}.
parse(ControllerModule) ->
    Attributes = ControllerModule:module_info(attributes),
    case proplists:get_value(routes, Attributes) of
        undefined -> undefined;
        Routes    -> {ControllerModule, parse(Routes, [])}
    end.

parse([], Acc) -> lists:reverse(Acc);
parse([Method, Path, Action | Rest], Acc) ->
    Tokens = string:tokens(Path, "/"),
    TypedTokens = lists:foldr(
        fun(Token, Acc2) ->
            case Token of
                [$:] ++ Param -> [{param, Param} | Acc2];
                _             -> [{fixed, Token} | Acc2]
            end
        end,
        [],
        Tokens
    ),
    parse(Rest, [{Method, TypedTokens, Action} | Acc]).

%-------------------------------------------------------------------------------

%% Converts {c_articles, [{get, [{fixed, "articles"}, {param, "id"}], show}]} to
%% "route_tokens(get, [\"articles\", Id]) -> {c_articles, show, [{id, Id}]};".
route_tokens_gen(Forms) ->
    lists:foldl(
        fun({ControllerModule, Routes}, Acc) ->
            [
                Acc, "\n",
                "% ", atom_to_list(ControllerModule), "\n",
                lists:foldl(
                    fun({Method, TypedTokens, Action}, Acc2) ->
                        PathPattern = in_path_pattern(TypedTokens, undefined),
                        Params = in_params(TypedTokens),
                        [
                            Acc2,
                            io_lib:format(
                                "route_tokens(~p, ~s) -> {~p, ~p, ~s};\n",
                                [Method, PathPattern, ControllerModule, Action, Params]
                            )
                        ]
                    end,
                    [],
                    Routes
                )
            ]
        end,
        [],
        Forms
    ).

%% Converts [{fixed, "articles"}, {param, "id"}] to "[\"articles\", Id]".
in_path_pattern(TypedTokens, Prefix) ->
    Elems = lists:map(
        fun(TypedToken) ->
            case TypedToken of
                {fixed, Fixed} -> [$"] ++ Fixed ++ [$"];
                {param, Param} -> snake_to_camel(Param)
            end
        end,
        TypedTokens
    ),
    case Prefix of
        undefined -> [$[] ++ string:join(Elems, ", ") ++ [$]];
        _         -> [$[] ++ string:join([Prefix | Elems], ", ") ++ [$]]
    end.

%% Converts [{fixed, "articles"}, {param, "id"}] to "[{id, Id}]".
in_params(TypedTokens) ->
    Params = lists:foldr(
        fun(TypedToken, Acc) ->
            case TypedToken of
                {fixed, _Fixed} -> Acc;

                {param,  Param} ->
                    C = snake_to_camel(Param),
                    [["{\"", Param, "\", ", C, "}"] | Acc]
            end
        end,
        [],
        TypedTokens
    ),
    [$[] ++ string:join(Params, ", ") ++ [$]].

%-------------------------------------------------------------------------------

%% Converts {c_articles, [{get, [{fixed, "articles"}, {param, "id"}], show}]} to
%% "path(articles, show, [{id, Id}]) -> [\"/\", \"articles\", \"/\", Id]".
path_gen(Forms) ->
    lists:foldl(
        fun({ControllerModule, Routes}, Acc) ->
            [
                Acc, "\n",
                "% ", atom_to_list(ControllerModule), "\n",
                lists:foldl(
                    fun({_Method, TypedTokens, Action}, Acc2) ->
                        PathPattern = out_path_pattern(TypedTokens, "\"/\""),
                        Params = out_params(TypedTokens),
                        [$c, $_ | ControllerS] = atom_to_list(ControllerModule),
                        Controller = list_to_atom(ControllerS),
                        [
                            Acc2,
                            io_lib:format(
                                "path(~p, ~p, ~s) -> ~s;\n",
                                [Controller, Action, Params, PathPattern]
                            )
                        ]
                    end,
                    [],
                    Routes
                )
            ]
        end,
        [],
        Forms
    ).

%% Converts [{fixed, "articles"}, {param, "id"}] to "[\"articles\", Id]".
out_path_pattern(TypedTokens, Prefix) ->
    Elems = lists:map(
        fun(TypedToken) ->
            case TypedToken of
                {fixed, Fixed} -> [$"] ++ Fixed ++ [$"];
                {param, Param} -> snake_to_camel(Param)
            end
        end,
        TypedTokens
    ),
    case Prefix of
        undefined -> [$[] ++ string:join(Elems, ", \"/\", ") ++ [$]];
        _         -> [$[] ++ Prefix ++ string:join(Elems, ", \"/\", ") ++ [$]]
    end.

%% Converts [{fixed, "articles"}, {param, "id"}] to "[Id]".
out_params(TypedTokens) ->
    Params = lists:foldr(
        fun(TypedToken, Acc) ->
            case TypedToken of
                {fixed, _Fixed} -> Acc;
                {param,  Param} -> [snake_to_camel(Param) | Acc]
            end
        end,
        [],
        TypedTokens
    ),
    [$[] ++ string:join(Params, ", ") ++ [$]].

%-------------------------------------------------------------------------------

%% Converts snake_case to CamelCase.
snake_to_camel(String) ->
    % Capitalize
    [F | Rest] = String,
    CF = F - 32,  % a: 97, A: 65
    [CF | snake_to_camel2(Rest)].

snake_to_camel2([]) -> [];
snake_to_camel2([$_, S | Rest]) ->
    CS = S - 32,
    [CS | snake_to_camel2(Rest)];
snake_to_camel2([H | Rest]) ->
    [H | snake_to_camel2(Rest)].

%-------------------------------------------------------------------------------

%% Params is not a proplists, just a list of params in the same order as in routes.
%% If the a param is an integer or a float, It will be converted to string so that
%% because the return value is an io list of strings.
path(Controller, Action, Params) ->
    Params2 = lists:map(
        fun
            (Param) when is_integer(Param)-> integer_to_list(Param);
            (Param) when is_float(Param)  -> float_to_list(Param);
            (Param)                       -> yaws_api:url_encode(Param)  % string()
        end,
        Params
    ),
    ale_routes:path(Controller, Action, Params2).

path(Action, Params) when is_list(Params) ->
    Controller = ale_pd:params(controller),
    path(Controller, Action, Params);
path(Controller, Action) ->
    path(Controller, Action, []).

path(Action) ->
    Controller = ale_pd:params(controller),
    path(Controller, Action, []).
